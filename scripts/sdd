#!/bin/bash
# SDD Enforcement Tool
# Usage: ./scripts/sdd {new|check|archive|list}

set -e

DOCS_ROOT="docs-framework"
CHANGES_DIR="$DOCS_ROOT/changes"
TEMPLATES_DIR="$DOCS_ROOT/templates"
SPECS_DIR="$DOCS_ROOT/specs/functional"

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

function print_usage {
    echo "Usage: $0 {new|check|archive|list|check-active}"
    echo "  new <feature>         Create a new feature proposal"
    echo "  check <feature> plan  Validate spec to proceed to planning"
    echo "  check-active          (Internal) Check if any active spec exists (for git hook)"
    echo "  archive <feature>     Archive a completed feature"
    echo "  list                  List active features"
}

function ensure_templates {
    if [ ! -f "$TEMPLATES_DIR/spec-template.md" ]; then
        echo -e "${RED}Error: Template spec-template.md not found in $TEMPLATES_DIR${NC}"
        exit 1
    fi
}

function cmd_new {
    FEATURE=$1
    if [ -z "$FEATURE" ]; then
        echo -e "${RED}Error: Feature name required.${NC}"
        print_usage
        exit 1
    fi

    TARGET_DIR="$CHANGES_DIR/$FEATURE"
    if [ -d "$TARGET_DIR" ]; then
        echo -e "${RED}Error: Feature '$FEATURE' already exists.${NC}"
        exit 1
    fi

    ensure_templates
    mkdir -p "$TARGET_DIR"
    cp "$TEMPLATES_DIR/spec-template.md" "$TARGET_DIR/spec.md"
    
    # Replace placeholder with feature name if simple replacement is possible, otherwise leave as is
    sed -i "s/\[Feature Name\]/$FEATURE/g" "$TARGET_DIR/spec.md" || true

    echo -e "${GREEN}✓ Created feature '$FEATURE' in $TARGET_DIR${NC}"
    echo -e "Next step: Edit $TARGET_DIR/spec.md to define your requirements."
}

function cmd_check_plan {
    FEATURE=$1
    SPEC_FILE="$CHANGES_DIR/$FEATURE/spec.md"
    
    if [ ! -f "$SPEC_FILE" ]; then
        echo -e "${RED}Error: Spec file not found for '$FEATURE'.${NC}"
        exit 1
    fi

    # Simple check: Does it still contain placeholder text?
    if grep -q "\[Brief description" "$SPEC_FILE"; then
        echo -e "${RED}Error: Spec file contains default template placeholders.${NC}"
        echo "Please edit the Summary section in $SPEC_FILE"
        exit 1
    fi

    echo -e "${GREEN}✓ Spec for '$FEATURE' looks valid. You may proceed to create a Plan.${NC}"
    
    # Optional: Create plan.md from template if it doesn't exist
    PLAN_FILE="$CHANGES_DIR/$FEATURE/plan.md"
    if [ ! -f "$PLAN_FILE" ]; then
        cp "$TEMPLATES_DIR/plan-template.md" "$PLAN_FILE"
        sed -i "s/\[Feature Name\]/$FEATURE/g" "$PLAN_FILE" || true
        echo -e "${YELLOW}Created draft plan at $PLAN_FILE${NC}"
    fi
}

function cmd_check_active {
    # This is used by the git hook.
    # Logic: If we are committing code, we MUST have at least one active feature with a modified spec/plan.
    # OR simpler: Just check if 'changes' directory is not empty.
    
    if [ -z "$(ls -A $CHANGES_DIR 2>/dev/null)" ]; then
        # Check if we are actually modifying code files.
        # This part is tricky in a raw script without git context, 
        # but usually the hook calls this. 
        # We will assume if this is called, we want to enforce presence of a spec.
        echo -e "${RED}BLOCKER: No active feature spec found in $CHANGES_DIR${NC}"
        echo -e "You are trying to commit code without an active SDD feature."
        echo -e "Run '${YELLOW}./scripts/sdd new <feature-name>${NC}' first."
        exit 1
    fi
    
    # Further check: Is the spec actually filled out?
    # We'll just check the first found feature for now.
    FIRST_FEATURE=$(ls $CHANGES_DIR | head -n 1)
    SPEC_FILE="$CHANGES_DIR/$FIRST_FEATURE/spec.md"
    
    if grep -q "\[Brief description" "$SPEC_FILE"; then
         echo -e "${RED}BLOCKER: The active spec '$FIRST_FEATURE' is still a template.${NC}"
         echo -e "Please fill out $SPEC_FILE before committing."
         exit 1
    fi

    echo -e "${GREEN}✓ Active spec found: $FIRST_FEATURE${NC}"
    exit 0
}

function cmd_archive {
    FEATURE=$1
    if [ -z "$FEATURE" ]; then
        echo -e "${RED}Error: Feature name required.${NC}"
        exit 1
    fi
    
    TARGET_DIR="$CHANGES_DIR/$FEATURE"
    if [ ! -d "$TARGET_DIR" ]; then
        echo -e "${RED}Error: Feature '$FEATURE' not found.${NC}"
        exit 1
    fi

    # In a real scenario, we might want to append the spec content to a master doc.
    # For now, we will just move it to a 'completed' folder or similar, 
    # OR just tell the user to manually merge.
    
    # Let's verify we are ready to archive
    echo -e "${YELLOW}Archiving feature '$FEATURE'...${NC}"
    
    # 1. Ensure target specs dir exists
    mkdir -p "$SPECS_DIR"
    
    # 2. Copy the spec to the permanent specs dir with a timestamp
    DATE_STR=$(date +%Y%m%d)
    ARCHIVE_NAME="${FEATURE}_${DATE_STR}.md"
    cp "$TARGET_DIR/spec.md" "$SPECS_DIR/$ARCHIVE_NAME"
    
    # 3. Remove the changes dir
    rm -rf "$TARGET_DIR"
    
    echo -e "${GREEN}✓ Feature '$FEATURE' archived to $SPECS_DIR/$ARCHIVE_NAME${NC}"
    echo -e "${GREEN}✓ Active change directory removed.${NC}"
}

function cmd_list {
    ls -1 "$CHANGES_DIR"
}

case "$1" in
    new)
        cmd_new "$2"
        ;;
    check)
        if [ "$3" == "plan" ]; then
            cmd_check_plan "$2"
        else
            echo "Unknown check type. Use 'plan'."
            exit 1
        fi
        ;;
    check-active)
        cmd_check_active
        ;;
    archive)
        cmd_archive "$2"
        ;;
    list)
        cmd_list
        ;;
    *)
        print_usage
        exit 1
        ;;
esac
